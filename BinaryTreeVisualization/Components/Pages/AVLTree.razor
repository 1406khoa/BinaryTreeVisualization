﻿
@page "/avltree"
@rendermode InteractiveServer
@inject BinaryTreeService binaryTreeService
@inject AVLTreeService avlTreeService
@inject IJSRuntime JSRuntime

<PageTitle>AVL Tree</PageTitle>

<div class="first-component">
    <div class="find-operation">
        <p class="title">Find Node</p>
        <div>
            <select>
                <option value="shortest-path">Shortest Path</option>
                <option value="dfs">DFS</option>
                <option value="bfs">BFS</option>
            </select>
            <input class="find-input" type="number" @bind="newNodeValue" />
            <button class="button" disabled="@isTraversing">Find</button>
        </div>
    </div>

    <div class="traverse-tree">
        <p class="title">Selected Traversal Method</p>
        <div>
            <select @onchange="OnTraversalMethodChange">
                <option value="in-order" selected>In-order (LNR)</option>
                <option value="pre-order">Pre-order (NLR)</option>
                <option value="post-order">Post-order (LRN)</option>
                <option value="reverse-in-order">Reverse In-order (RNL)</option>
            </select>
            <button class="button" disabled="@isTraversing">Traverse</button>
        </div>
    </div>

    <div class="speed-control">
        <p class="title-speed">@($"Animation Speed: x{Val3}")</p>
        <div class="custom-slider">
            <MatSlider class="slider" @bind-Value="@Val3" Discrete="true" Pin="true" TValue="int" ValueMin="1" ValueMax="3"></MatSlider>
        </div>
    </div>
</div>

<div class="random-tree">
    <p class="title">Create Random Tree</p>
    <div>
        <label>Number of nodes:</label>
        <input type="number" @bind="nodeCount" />
        <label style="margin-left: 5px">Min:</label>
        <input type="number" @bind="minValue" />
        <label style="margin-left: 5px">Max:</label>
        <input type="number" @bind="maxValue" />
        <button class="create-random-button" @onclick="CreateRandomTree" disabled="@isTraversing">Create Random Tree</button>
        <button class="clear-button" @onclick="DeleteTree" disabled="@isTraversing">Clear Tree</button>
    </div>
</div>

<p class="title">Traversal Order</p>
<div style="background-color: #f0f0f0; padding: 10px; border: 1px solid #ccc; border-radius: 5px;">
    @traversalOrderFragment
</div>

<!-- Thông báo trạng thái -->
<div class="status-bar">
    <p class="status">@($"{statusMessage}")</p>
</div>

<!-- Khối SVG -->
<svg @oncontextmenu="OnSvgRightClick" width="100%" height="100vh" style="overflow: visible;">
    @foreach (var line in lines)
    {
        <line x1="@line.nodeFrom.AnimatedX" y1="@line.nodeFrom.AnimatedY"
              x2="@line.nodeTo.AnimatedX" y2="@line.nodeTo.AnimatedY"
              stroke="@((line.IsHighlighted) ? "#FFC107" : "black")" stroke-width="2" />
    }


    @foreach (var nodePosition in nodePositions)
    {
        <!-- Vẽ hình tròn cho node, tô màu nếu là node được thêm -->
        <circle class="node-circle @((nodePosition.node == selectedNode) ? "selected-node" : "")"
                cx="@nodePosition.node.AnimatedX" cy="@nodePosition.node.AnimatedY" r="20" stroke="black" stroke-width="2"
                fill="@GetNodeFillColor(nodePosition.node)"
                @onclick="(() => OnNodeClick(nodePosition.node))"
                @oncontextmenu="(() => ShowDropdown(nodePosition.node))" />

        <!-- Sử dụng RenderFragment để in giá trị -->
        @((RenderFragment)((builder) =>
            {
                builder.OpenElement(0, "text");
                builder.AddAttribute(1, "x", nodePosition.x);
                builder.AddAttribute(2, "y", nodePosition.y);
                builder.AddAttribute(3, "text-anchor", "middle");
                builder.AddAttribute(4, "dominant-baseline", "middle");
                builder.AddAttribute(5, "dy", "0.35em"); // Điều chỉnh vị trí văn bản
                builder.AddAttribute(6, "font-size", "12");
                builder.AddAttribute(7, "font-weight", "bold");
                builder.AddAttribute(8, "fill", "black");
                builder.AddAttribute(9, "cursor", "pointer");
                builder.AddAttribute(10, "onclick", EventCallback.Factory
                .Create(this, () => OnNodeClick(nodePosition.node)));
                builder.AddAttribute(11, "oncontextmenu", EventCallback.Factory
                .Create(this, () => ShowDropdown(nodePosition.node)));
                builder.AddContent(12, nodePosition.node.Value.ToString());
                builder.CloseElement();
            }))
    }

    <!-- Dropdown menu -->
    @if (showDropdown)
    {
        <foreignObject x="@dropdownX" y="@dropdownY" width="180" height="180"
                       xmlns:xhtml="http://www.w3.org/1999/xhtml">
            <xhtml:div class="dropdown-menu">
                <input class="dropdown-input" type="number" @bind="newNodeValue" />
                <xhtml:button class="dropdown-button" @onclick="AddNode"
                              disabled="@isTraversing">Add Node</xhtml:button>
                <xhtml:button class="dropdown-button" disabled="@(isRootAbsent || isTraversing || selectedNode == null)">Update Node</xhtml:button>
                <xhtml:button class="dropdown-button" disabled="@(isRootAbsent || isTraversing || selectedNode == null)">Delete Node</xhtml:button>
            </xhtml:div>
        </foreignObject>
    }

    <!-- Hình tròn kiểm soát viên -->
    @if (showController)
    {
        <circle cx="@controllerPosition.X" cy="@controllerPosition.Y" r="20" stroke="green" stroke-width="3" fill="none" />
    }
</svg>

@code {
	@using BinaryTreeVisualization.Components.Services;
    @using System.Numerics

    // Cụm biến liên quan đến Node và Node Selection
    private int newNodeValue;
    private NodeService? selectedNode;
    private List<(NodeService node, double x, double y)> nodePositions = new();
    List<(NodeService nodeFrom, NodeService nodeTo, bool IsHighlighted, Guid LineID)> lines = new();

    // Cụm biến liên quan đến Traversal và Duyệt cây
    private string selectedTraversalMethod = "in-order";
    private string traversalOrderDisplay = "";
    private bool isTraversing = false;
    private List<TraversalStep> traversalSteps = new();

    public class TraversalStep
    {
        public int Value { get; set; }
        public NodeService Node { get; set; } // Thêm thuộc tính Node


        public TraversalStep(NodeService node)
        {
            Node = node;
            Value = node.Value;
        }
    }

    private RenderFragment traversalOrderFragment = builder => { };
    public List<int> traversalOrder = new(); // Lưu các giá trị đã duyệt

    //Biến liên quan tới tìm node theo DFS hoặc BFS
    private string selectedSearchMethod = "shortest-path"; // Phương thức tìm kiếm được chọn

    // Cụm biến liên quan đến Random Tree Generation
    private int nodeCount { get; set; } = 10;
    private int minValue { get; set; } = 0;
    private int maxValue { get; set; } = 100;

    // Cụm biến liên quan đến Dropdown Menu
    private bool showDropdown = false;
    private double dropdownX, dropdownY;

    // Cụm biến liên quan đến Animation và Controller
    private bool showController = false;
    private Vector2 controllerPosition = new Vector2(0, 0); // Vị trí mặc định của controller
    private int _val3 = 1;
    public int Val3
    {
        get => _val3;
        set
        {
            _val3 = value;
            this.StateHasChanged();
        }
    }

    // Biến thông báo trạng thái
    private string statusMessage = "";

    // Biến kiểm tra điều kiện để disable các nút
    private bool isRootAbsent => avlTreeService.Root == null;

    private string GetNodeFillColor(NodeService node)
    {
        if (node.IsHighlighted) // Ưu tiên màu vàng nếu node đang được tìm kiếm
        {
            return "#FFC107"; //Vàng hổ phách nhạt (Amber)
        }
        else if (node == selectedNode) // Nếu node được chọn, tô màu xanh lá
        {
            return "lightgreen";
        }
        return "white"; // Màu mặc định cho các node khác
    }

    private async Task AddNode()
    {
        HideDropdown();

        // Lưu vị trí cũ trước khi thêm node
        if (avlTreeService.Root != null)
        {
            avlTreeService.StoreOldPositions(avlTreeService.Root);
        }

        var newNodeID = avlTreeService.AddNode(newNodeValue);
        if (newNodeID == Guid.Empty)
        {
            statusMessage = $"Node {newNodeValue} already exists";
        }
        else
        {
            // Cập nhật vị trí mới của các node
            avlTreeService.ArrangeNodePositions(avlTreeService.Root, binaryTreeService.GetRootX(), binaryTreeService.GetRootY(), 200);

            UpdateTreeDrawing();

            if (avlTreeService.DidRotate)
            {
                // Thực hiện animation một lần sau khi cây đã cân bằng
                await AnimateRotations();
            }
            else
            {
                // Nếu không xoay, node mới xuất hiện ngay lập tức
                avlTreeService.SetAnimatedPositionToCurrent();
                UpdateTreeDrawing();
            }
        }
    }

    private async Task AnimateRotations()
    {
        int duration = 1000; // Thời gian animation
        int steps = 60;
        int delay = duration / steps;

        for (int i = 1; i <= steps; i++)
        {
            double t = (double)i / steps;

            foreach (var node in GetAllNodes(avlTreeService.Root))
            {
                if (node == null) continue;

                node.AnimatedX = Bezier(node.OldPositionX, (node.OldPositionX + node.PositionX) / 2, node.PositionX, t);
                node.AnimatedY = Bezier(node.OldPositionY, (node.OldPositionY + node.PositionY) / 2, node.PositionY, t);
            }

            UpdateTreeDrawing();
            await Task.Delay(delay);
        }

        foreach (var node in GetAllNodes(avlTreeService.Root))
        {
            if (node == null) continue;

            node.AnimatedX = node.PositionX;
            node.AnimatedY = node.PositionY;
        }

        UpdateTreeDrawing();
    }

    private List<NodeService> GetAllNodes(NodeService? node)
    {
        var nodes = new List<NodeService>();
        if (node == null) return nodes;

        nodes.Add(node);
        nodes.AddRange(GetAllNodes(node.LeftChild));
        nodes.AddRange(GetAllNodes(node.RightChild));

        return nodes;
    }
    private double Bezier(double p0, double p1, double p2, double t)
    {
        return Math.Pow(1 - t, 2) * p0 + 2 * (1 - t) * t * p1 + Math.Pow(t, 2) * p2;
    }


    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("preventContextMenu");
            await JSRuntime.InvokeVoidAsync("addOutsideClickListener", DotNetObjectReference.Create(this));
        }
    }

    // Hàm hiển thị dropdown menu khi click chuột phải vào không gian trống
    private void ShowDropdownForRoot(MouseEventArgs e)
    {
        dropdownX = e.ClientX - 250;
        dropdownY = e.ClientY - 275;
        showDropdown = true;

        UpdateTreeDrawing();
        StateHasChanged();
    }

    private void OnSvgRightClick(MouseEventArgs e)
    {
        if (selectedNode == null)
        {
            ShowDropdownForRoot(e);
        }
        StateHasChanged();
    }

    // Hàm hiển thị dropdown menu khi click chuột phải vào node
    private void ShowDropdown(NodeService? node = null)
    {
        if (node != null)
        {
            selectedNode = node;
            newNodeValue = selectedNode.Value;
            statusMessage = $"Node {node.Value} is selected";
            dropdownX = node.PositionX + 15;
            dropdownY = node.PositionY - 67;
            showDropdown = true;
        }

        UpdateTreeDrawing();
        StateHasChanged();
    }

    [JSInvokable]
    public void HideDropdown()
    {
        showDropdown = false;
        StateHasChanged();
    }

    private void OnTraversalMethodChange(ChangeEventArgs e)
    {
        selectedTraversalMethod = e.Value?.ToString() ?? "in-order"; // Lấy kiểu duyệt từ select box
        statusMessage = $"Traversal method changed to {selectedTraversalMethod}."; // Cập nhật thông báo

        // Chỉ cần thay đổi kiểu duyệt mà không tái cấu trúc lại cây
        avlTreeService.SetTraversalType(selectedTraversalMethod);
        UpdateTreeDrawing(); // Vẽ lại cây theo kiểu duyệt mới
    }

    private void RemoveHighlighting()
    {
        foreach (var node in nodePositions)
        {
            node.node.IsHighlighted = false;
        }

        for (int i = 0; i < lines.Count; i++)
        {
            lines[i] = (lines[i].nodeFrom, lines[i].nodeTo, IsHighlighted: false, lines[i].LineID);
        }
    }


    private void HighlightNodeAndLine(Guid newNodeID)
    {
        var newNode = nodePositions.FirstOrDefault(np => np.node.NodeID == newNodeID);
        if (newNode.node == null) return;

        newNode.node.IsHighlighted = true;

        var parentLine = lines.FirstOrDefault(line => line.nodeTo == newNode.node);
        if (parentLine != default)
        {
            int index = lines.IndexOf(parentLine);
            if (index != -1)
            {
                lines[index] = (lines[index].nodeFrom, lines[index].nodeTo, IsHighlighted: true, lines[index].LineID);
            }
        }
    }


    private void UpdateTreeDrawing()
    {
        var nodesInTraversalOrder = binaryTreeService.TraverseTree(avlTreeService.Root, selectedTraversalMethod);

        if (avlTreeService.Root != null)
        {
            avlTreeService.ArrangeNodePositions(avlTreeService.Root, binaryTreeService.GetRootX(), binaryTreeService.GetRootY(), 200);
        }

        nodePositions = avlTreeService.GetNodePositions(avlTreeService.Root, selectedTraversalMethod);

        // Tạo danh sách lines mới
        lines.Clear();
        PopulateLines(avlTreeService.Root);

        // Cập nhật dãy số duyệt cây
        traversalOrderDisplay = string.Join(" -> ", nodesInTraversalOrder.Select(n => n.Value));
        StateHasChanged();
    }

    private void PopulateLines(NodeService? node)
    {
        if (node == null) return;

        if (node.LeftChild != null)
        {
            lines.Add((nodeFrom: node, nodeTo: node.LeftChild, IsHighlighted: false, LineID: Guid.NewGuid()));
            PopulateLines(node.LeftChild);
        }

        if (node.RightChild != null)
        {
            lines.Add((nodeFrom: node, nodeTo: node.RightChild, IsHighlighted: false, LineID: Guid.NewGuid()));
            PopulateLines(node.RightChild);
        }
    }



    private void CreateRandomTree()
    {
        traversalOrderFragment = builder => { };
        avlTreeService.ResetTree();
        avlTreeService.BuildRandomTree(nodeCount, minValue, maxValue);

        // Sắp xếp vị trí các node sau khi tạo cây
        avlTreeService.ArrangeNodePositions(avlTreeService.Root, binaryTreeService.GetRootX(), binaryTreeService.GetRootY(), 200);

        // Cập nhật AnimatedX và AnimatedY để hiển thị cây ngay lập tức
        avlTreeService.SetAnimatedPositionToCurrent();

        StateHasChanged();
        UpdateTreeDrawing();
    }

    private void DeleteTree()
    {
        avlTreeService.ResetTree();
        UpdateTreeDrawing();
        DeselectNode();
        StateHasChanged();
    }

    //Hàm để lưu thông tin và tô màu node được chọn
    private void OnNodeClick(NodeService node)
    {
        if (selectedNode == node)
        {
            DeselectNode();
        }
        else
        {
            selectedNode = node; // Gán node mới được chọn
            newNodeValue = selectedNode.Value; // Hiển thị giá trị của node trong input
            statusMessage = $"Node {node.Value} is selected";
        }

        UpdateTreeDrawing();
    }

    public void DeselectNode()
    {
        selectedNode = null; // Hủy chọn node
        newNodeValue = 0; // Xóa giá trị hiện tại nếu cần
        statusMessage = "Node deselected.";
        StateHasChanged();
    }
}