@page "/bst"
@rendermode InteractiveServer
@inject BSTService bstService
@inject BinaryTreeService binaryTreeService
@inject IJSRuntime JSRuntime

<PageTitle>Binary Search Tree</PageTitle>

<div class="first-component">
    <div class="find-operation">
        <p class="title">Search Node</p>
        <div>
            <select @onchange="OnSearchMethodChange">
                <option value="bst">Binary Search</option>
                <option value="dfs">DFS</option>
                <option value="bfs">BFS</option>
            </select>
            <input class="find-input" type="number" @bind="newNodeValue" />
            <button class="button" @onclick="StartFindNodeAnimation" disabled="@isTraversing">Search</button>
        </div>
    </div>

    <div class="traverse-tree">
        <p class="title">Selected Traversal Method</p>
        <div>
            <select @onchange="OnTraversalMethodChange">
                <option value="in-order" selected>In-order (LNR)</option>
                <option value="pre-order">Pre-order (NLR)</option>
                <option value="post-order">Post-order (LRN)</option>
                <option value="reverse-in-order">Reverse In-order (RNL)</option>
            </select>
            <button class="button" @onclick="StartTraversal" disabled="@isTraversing">Traverse</button>
        </div>
    </div>

    <div class="speed-control">
        <p class="title-speed">@($"Animation Speed: x{Val3} (Duration: {1000 / Val3}ms)")</p>
        <div class="custom-slider">
            <MatSlider class="slider" @bind-Value="@Val3" Discrete="true" Pin="true" TValue="int" ValueMin="1" ValueMax="3"></MatSlider>
        </div>
    </div>
</div>

<div class="random-tree">
    <p class="title">Create Random Tree</p>
    <div>
        <label>Number of nodes:</label>
        <input type="number" @bind="nodeCount" />
        <label style="margin-left: 5px">Min:</label>
        <input type="number" @bind="minValue" />
        <label style="margin-left: 5px">Max:</label>
        <input type="number" @bind="maxValue" />
        <button class="create-random-button" @onclick="CreateRandomTree" disabled="@isTraversing">Create Random Tree</button>
        <button class="clear-button" @onclick="DeleteTree" disabled="@isTraversing">Clear Tree</button>
    </div>
</div>

<p class="title">Traversal Order</p>
<div style="background-color: #f0f0f0; padding: 5px; border: 1px solid #ccc; border-radius: 5px;">
    <span style="padding: 10px">
        @traversalOrderFragment
    </span>
</div>

<!-- Thông báo trạng thái -->
<div class="status-bar">
    <p class="status">@($"{statusMessage}")</p>
</div>

<!-- Khối SVG -->
<svg @oncontextmenu="OnSvgRightClick" width="100%" height="100vh" style="overflow: visible;">
    @foreach (var line in lines)
    {
        <!-- Đường nối giữa các node -->
        <line x1="@line.x1" y1="@line.y1" x2="@line.x2" y2="@line.y2"
              stroke="@((line.IsHighlighted) ? "#FFC107" : "black")" stroke-width="2" />
    }

    @foreach (var nodePosition in nodePositions)
    {
        <!-- Vẽ hình tròn cho node, tô màu nếu là node được thêm -->
        <circle class="node-circle @((nodePosition.node == selectedNode) ? "selected-node" : "")"
                cx="@nodePosition.x" cy="@nodePosition.y" r="20" stroke="black" stroke-width="2"
                fill="@GetNodeFillColor(nodePosition.node)"
                @onclick="(() => OnNodeClick(nodePosition.node))"
                @oncontextmenu="(() => ShowDropdown(nodePosition.node))" />

        <!-- Sử dụng RenderFragment để in giá trị -->
        @((RenderFragment)((builder) =>
            {
                builder.OpenElement(0, "text");
                builder.AddAttribute(1, "x", nodePosition.x);
                builder.AddAttribute(2, "y", nodePosition.y);
                builder.AddAttribute(3, "text-anchor", "middle");
                builder.AddAttribute(4, "dominant-baseline", "middle");
                builder.AddAttribute(5, "dy", "0.35em"); // Điều chỉnh vị trí văn bản
                builder.AddAttribute(6, "font-size", "12");
                builder.AddAttribute(7, "font-weight", "bold");
                builder.AddAttribute(8, "fill", "black");
                builder.AddAttribute(9, "cursor", "pointer");
                builder.AddAttribute(10, "onclick", EventCallback.Factory
                .Create(this, () => OnNodeClick(nodePosition.node)));
                builder.AddAttribute(11, "oncontextmenu", EventCallback.Factory
                .Create(this, () => ShowDropdown(nodePosition.node)));
                builder.AddContent(12, nodePosition.node.Value.ToString());
                builder.CloseElement();
            }))
    }

    <!-- Dropdown menu -->
    @if (showDropdown)
    {
        <foreignObject x="@dropdownX" y="@dropdownY" width="180" height="180"
                       xmlns:xhtml="http://www.w3.org/1999/xhtml">
            <xhtml:div class="dropdown-menu">
                <input class="dropdown-input" type="number" @bind="newNodeValue" />
                <xhtml:button class="dropdown-button" @onclick="AddNode"
                              disabled="@isTraversing">Add Node</xhtml:button>
                <xhtml:button class="dropdown-button" disabled="@(isRootAbsent || isTraversing || selectedNode == null)" 
                        @onclick="UpdateNode">Update Node</xhtml:button>
                <xhtml:button class="dropdown-button" disabled="@(isRootAbsent || isTraversing || selectedNode == null)" 
                        @onclick="DeleteNode">Delete Node</xhtml:button>
            </xhtml:div>
        </foreignObject>
    }

    <!-- Hình tròn kiểm soát viên -->
    @if (showController)
    {
        <circle cx="@controllerPosition.X" cy="@controllerPosition.Y" r="20" stroke="green" stroke-width="3" fill="none" />
    }
</svg>

@code {
    @using BinaryTreeVisualization.Components.Services
    @using System.Numerics
    private CancellationTokenSource? cancellationTokenSource;

    // Cụm biến liên quan đến Node và Node Selection
    private int newNodeValue;
    private NodeService? selectedNode;
    private List<(NodeService node, double x, double y)> nodePositions = new();
    private List<(double x1, double y1, double x2, double y2, bool IsHighlighted, Guid LineID)> lines = new();

    // Cụm biến liên quan đến Traversal và Duyệt cây
    private string selectedTraversalMethod = "in-order";
    private bool isTraversing = false;
    private List<TraversalStep> traversalSteps = new();

    public class TraversalStep
    {
        public int Value { get; set; }
        public NodeService Node { get; set; } // Thêm thuộc tính Node


        public TraversalStep(NodeService node)
        {
            Node = node;
            Value = node.Value;
        }
    }

    private RenderFragment traversalOrderFragment = builder => { };
    public List<int> traversalOrder = new(); // Lưu các giá trị đã duyệt

    //Biến liên quan tới tìm node theo DFS hoặc BFS
    private string selectedSearchMethod = "bst"; // Phương thức tìm kiếm được chọn

    // Cụm biến liên quan đến Random Tree Generation
    private int nodeCount { get; set; } = 10;
    private int minValue { get; set; } = 0;
    private int maxValue { get; set; } = 100;

    // Cụm biến liên quan đến Dropdown Menu
    private bool showDropdown = false;
    private double dropdownX, dropdownY;

    // Cụm biến liên quan đến Animation và Controller
    private bool showController = false;
    private Vector2 controllerPosition = new Vector2(0, 0); // Vị trí mặc định của controller
    private int _val3 = 1;
    public int Val3
    {
        get => _val3;
        set
        {
            _val3 = value;
            this.StateHasChanged();
        }
    }

    // Biến thông báo trạng thái
    private string statusMessage = "";

    // Biến kiểm tra điều kiện để disable các nút
    private bool isRootAbsent => bstService.Root == null;

    protected override void OnInitialized() // đặt controller ở vị trí mặc định
    {
        statusMessage = "";
        traversalOrderFragment = builder => { };
        RemoveHighlighting();
        DeselectNode();

        // Cài đặt vị trí kiểm soát viên ở node gốc
        if (bstService.Root != null)
        {
            controllerPosition = new Vector2((float)bstService.Root.PositionX, (float)bstService.Root.PositionY);
        }
        else
        {
            controllerPosition = new Vector2(800, 50); // Nếu chưa có node gốc, đặt vị trí mặc định
        }

        showController = false; // Kiểm soát viên ẩn
    }

    private string GetNodeFillColor(NodeService node)
    {
        if (node == selectedNode) // Ưu tiên màu xanh lá nếu node được chọn
        {
            return "lightgreen";
        }
        else if (node.IsFound)
        {
            return "#87CEEB";
        }
        else if (node.IsHighlighted) // Tô màu vàng cho node đang được tìm kiếm
        {
            return "#FFC107"; // Vàng hổ phách nhạt (Amber)
        }
        return "white"; // Màu mặc định cho các node khác
    }

    private async Task AddNode()
    {
        OnInitialized();
        HideDropdown();
        isTraversing = true;
        // Tìm node cha cho node mới
        var parentNode = bstService.FindParentNode(newNodeValue);

        if (parentNode != null)
        {
            // Lấy đường đi từ gốc đến node cha
            var pathToParent = GetPathToNode(parentNode);

            // Di chuyển controller theo đường đi tới node cha
            await MoveControllerAlongPath(pathToParent);
        }

        // Sau khi controller đến node cha, thêm node mới
        var newNodeID = bstService.AddNode(newNodeValue);
        statusMessage = $"Add {newNodeValue} successfully";
        // Kiểm tra xem có phải là node đã tồn tại không
        if (newNodeID == Guid.Empty)
        {
            statusMessage = $"Node {newNodeValue} already exists";
            isTraversing = false;
            showController = false;
            await Task.Delay(500);
            UpdateTreeDrawing();
            StateHasChanged();
        }
        else
        {
            UpdateTreeDrawing();
            showController = false;
            HighlightNode(newNodeID);
            await Task.Delay(1000);

            UpdateTreeDrawing();
            StateHasChanged();
            isTraversing = false;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("preventContextMenu");
            await JSRuntime.InvokeVoidAsync("addOutsideClickListener", DotNetObjectReference.Create(this));
        }
    }

    // Hàm hiển thị dropdown menu khi click chuột phải vào không gian trống
    private void ShowDropdownForRoot(MouseEventArgs e)
    {
        dropdownX = e.ClientX - 250;
        dropdownY = e.ClientY - 275;
        showDropdown = true;

        UpdateTreeDrawing();
        StateHasChanged();
    }

    private void OnSvgRightClick(MouseEventArgs e)
    {
        if (selectedNode == null)
        {
            ShowDropdownForRoot(e);
        }
        StateHasChanged();
    }

    // Hàm hiển thị dropdown menu khi click chuột phải vào node
    private void ShowDropdown(NodeService? node = null)
    {
        if (node != null)
        {
            selectedNode = node;
            newNodeValue = selectedNode.Value;
            statusMessage = $"Node {node.Value} is selected";
            dropdownX = node.PositionX + 15;
            dropdownY = node.PositionY - 67;
            showDropdown = true;
        }

        UpdateTreeDrawing();
        StateHasChanged();
    }

    [JSInvokable]
    public void HideDropdown()
    {
        showDropdown = false;
        StateHasChanged();
    }

    private void OnTraversalMethodChange(ChangeEventArgs e)
    {
        selectedTraversalMethod = e.Value?.ToString() ?? "in-order";
    }


    private async Task InOrderTraversalVisualization(NodeService? node, CancellationToken cancellationToken)
    {
        if (node == null || cancellationToken.IsCancellationRequested) return;

        // Duyệt nhánh trái
        if (node.LeftChild != null)
        {
            await MoveAlongPath(node, node.LeftChild);
            await InOrderTraversalVisualization(node.LeftChild, cancellationToken);
            await MoveAlongPath(node.LeftChild, node);
        }

        // Xử lý node hiện tại
        await VisitNode(node);

        // Duyệt nhánh phải
        if (node.RightChild != null)
        {
            await MoveAlongPath(node, node.RightChild);
            await InOrderTraversalVisualization(node.RightChild, cancellationToken);
            await MoveAlongPath(node.RightChild, node);
        }
    }


    private async Task PreOrderTraversalVisualization(NodeService? node, CancellationToken cancellationToken)
    {
        if (node == null || cancellationToken.IsCancellationRequested) return;

        // Xử lý node hiện tại
        await VisitNode(node);

        // Duyệt nhánh trái
        if (node.LeftChild != null)
        {
            // Di chuyển controller đến node con trái
            await MoveAlongPath(node, node.LeftChild);
            await PreOrderTraversalVisualization(node.LeftChild, cancellationToken);
            // Quay lại node cha
            await MoveAlongPath(node.LeftChild, node);
        }

        // Duyệt nhánh phải
        if (node.RightChild != null)
        {
            // Di chuyển controller đến node con phải
            await MoveAlongPath(node, node.RightChild);
            await PreOrderTraversalVisualization(node.RightChild, cancellationToken);
            // Quay lại node cha
            await MoveAlongPath(node.RightChild, node);
        }
    }

    private async Task PostOrderTraversalVisualization(NodeService? node, CancellationToken cancellationToken)
    {
        if (node == null) return;

        // Duyệt nhánh trái
        if (node.LeftChild != null)
        {
            // Di chuyển controller đến node con trái
            await MoveAlongPath(node, node.LeftChild);
            await PostOrderTraversalVisualization(node.LeftChild, cancellationToken);
            // Quay lại node cha
            await MoveAlongPath(node.LeftChild, node);
        }

        // Duyệt nhánh phải
        if (node.RightChild != null)
        {
            // Di chuyển controller đến node con phải
            await MoveAlongPath(node, node.RightChild);
            await PostOrderTraversalVisualization(node.RightChild, cancellationToken);
            // Quay lại node cha
            await MoveAlongPath(node.RightChild, node);
        }

        // Xử lý node hiện tại
        await VisitNode(node);
    }

    private async Task ReverseInOrderTraversalVisualization(NodeService? node, CancellationToken cancellationToken)
    {
        if (node == null) return;

        // Duyệt nhánh phải
        if (node.RightChild != null)
        {
            // Di chuyển controller đến node con phải
            await MoveAlongPath(node, node.RightChild);
            await ReverseInOrderTraversalVisualization(node.RightChild, cancellationToken);
            // Quay lại node cha
            await MoveAlongPath(node.RightChild, node);
        }

        // Xử lý node hiện tại
        await VisitNode(node);

        // Duyệt nhánh trái
        if (node.LeftChild != null)
        {
            // Di chuyển controller đến node con trái
            await MoveAlongPath(node, node.LeftChild);
            await ReverseInOrderTraversalVisualization(node.LeftChild, cancellationToken);
            // Quay lại node cha
            await MoveAlongPath(node.LeftChild, node);
        }
    }


    private async Task VisitNode(NodeService node)
    {
        await StartControllerMovement(new Vector2((float)node.PositionX, (float)node.PositionY));

        node.IsHighlighted = true;
        traversalSteps.Add(new TraversalStep(node));

        // Dừng lại để người dùng quan sát
        await Task.Delay((int)(200 / Val3));

        // Cập nhật giao diện sau khi hoàn thành
        UpdateTreeDrawing();
        UpdateTraversalOrderFragment(traversalSteps.Count - 1);
        StateHasChanged();
    }


    private async Task MoveAlongPath(NodeService fromNode, NodeService toNode)
    {
        var startPoint = new Vector2((float)fromNode.PositionX, (float)fromNode.PositionY);
        var endPoint = new Vector2((float)toNode.PositionX, (float)toNode.PositionY);

        float distance = Vector2.Distance(startPoint, endPoint);
        int steps = Math.Max(1, (int)(distance / 100000)); // Điều chỉnh theo nhu cầu

        for (int i = 1; i <= steps; i++)
        {
            float t = (float)i / steps;
            var intermediatePoint = Vector2.Lerp(startPoint, endPoint, t);

            await StartControllerMovement(intermediatePoint);

            // Giảm thời gian delay
            await Task.Delay((int)(16 / Val3)); // Điều chỉnh thời gian nếu cần
        }
    }

    private async Task StartTraversal()
    {
        if (isTraversing) return;
        // Hủy bỏ tác vụ trước đó nếu có
        cancellationTokenSource?.Cancel();
        cancellationTokenSource = new CancellationTokenSource();
        traversalSteps = new List<TraversalStep>();
        OnInitialized();
        isTraversing = true;
        statusMessage = "Traversing...";
        showController = true; // Hiển thị controller
        StateHasChanged(); // Cập nhật giao diện

        switch (selectedTraversalMethod.ToLower())
        {
            case "in-order":
                await InOrderTraversalVisualization(bstService.Root, cancellationTokenSource.Token);
                break;
            case "pre-order":
                await PreOrderTraversalVisualization(bstService.Root, cancellationTokenSource.Token);
                break;
            case "post-order":
                await PostOrderTraversalVisualization(bstService.Root, cancellationTokenSource.Token);
                break;
            case "reverse-in-order":
                await ReverseInOrderTraversalVisualization(bstService.Root, cancellationTokenSource.Token);
                break;
            default:
                await InOrderTraversalVisualization(bstService.Root, cancellationTokenSource.Token);
                break;
        }

        showController = false; // Ẩn controller sau khi duyệt xong
        statusMessage = "Finished!";
        isTraversing = false;
        StateHasChanged();
    }

    private void RemoveHighlighting()
    {
        foreach (var node in bstService.GetAllNodes())
        {
            node.IsHighlighted = false;
            node.IsFound = false;
        }
        UpdateTreeDrawing();
    }

    private void HighlightNode(Guid newNodeID)
    {
        // Tìm node mới dựa trên NodeID
        var newNode = nodePositions.FirstOrDefault(np => np.node.NodeID == newNodeID);
        if (newNode.node == null) return;  // Thoát nếu không tìm thấy node

        // Tô sáng node mới
        newNode.node.IsHighlighted = true;

        // Cập nhật giao diện
        UpdateTreeDrawing();
        StateHasChanged();
    }

    private void UpdateTreeDrawing()
    {

        if (bstService.Root != null)
        {
            bstService.ArrangeNodePositions(bstService.Root, binaryTreeService.GetRootX(), binaryTreeService.GetRootY(), 200);
        }

        nodePositions = bstService.GetNodePositions(bstService.Root);

        lines = bstService.GetLines()
                           .Select(line => (
                               line.x1, line.y1, line.x2, line.y2,
                               IsHighlighted: false,
                               LineID: Guid.NewGuid()
                           )).ToList();
        StateHasChanged();
    }

    private void CreateRandomTree()
    {
        showController = false;
        traversalOrderFragment = builder => { };
        bstService.ResetTree();
        statusMessage = "Random tree created";
        bstService.BuildRandomTree(nodeCount, minValue, maxValue);
        UpdateTreeDrawing();
    }

    private void DeleteTree()
    {
        showController = false;
        bstService.ResetTree();
        DeselectNode();
        UpdateTreeDrawing();
        statusMessage = "Tree cleared";
        StateHasChanged();
    }

    private async Task DeleteNode()
    {
        HideDropdown();
        // Tìm node cần xóa
        var nodeToDelete = bstService.FindNodeFromRoot(newNodeValue);

        if (nodeToDelete != null)
        {
            isTraversing = true;
            // Tìm đường đi từ gốc đến node cần xóa
            var pathToNode = GetPathToNode(nodeToDelete);

            // Di chuyển controller theo đường đi tới node cần xóa
            await MoveControllerAlongPath(pathToNode);

            // Sau khi controller đến node cần xóa, thực hiện xóa node
            bool isDeleted = bstService.DeleteNode(newNodeValue);

            // Kiểm tra nếu xóa thành công
            if (isDeleted)
            {
                UpdateTreeDrawing();
                OnInitialized();
                showController = false;
                UpdateTreeDrawing();
                statusMessage = $"Delete {newNodeValue} successfully!";
                isTraversing = false;

            }
            else
            {
                // Thông báo nếu không thể xóa (ví dụ: node không tồn tại)
                statusMessage = $"Node {newNodeValue} does not exist.";
                await Task.Delay(500);
                UpdateTreeDrawing();
                StateHasChanged();
                isTraversing = false;

            }
        }
        else
        {
            // Thông báo nếu node cần xóa không tồn tại
            statusMessage = $"Node {newNodeValue} does not exist.";
            await Task.Delay(500);
            UpdateTreeDrawing();
            StateHasChanged();
        }
        OnInitialized();

    }

    //Hàm để lưu thông tin và tô màu node được chọn
    private void OnNodeClick(NodeService node)
    {
        if (selectedNode == node)
        {
            DeselectNode();
        }
        else
        {
            selectedNode = node; // Gán node mới được chọn
            newNodeValue = selectedNode.Value; // Hiển thị giá trị của node trong input
            statusMessage = $"Node {node.Value} is selected.";
        }

        UpdateTreeDrawing();
    }

    public void DeselectNode()
    {
        selectedNode = null; // Hủy chọn node
        statusMessage = "Node deselected.";
        StateHasChanged();
    }

    private async Task UpdateNode()
    {
        HideDropdown();
        isTraversing = true;
        if (selectedNode != null)
        {
            // Kiểm tra xem giá trị mới đã tồn tại trong cây chưa
            var existingNode = bstService.FindNodeFromRoot(newNodeValue);
            if (existingNode != null)
            {
                // Nếu giá trị đã tồn tại, hiển thị thông báo và thoát
                statusMessage = $"Node with value {newNodeValue} already exists. Edit operation canceled.";
                isTraversing = false;
                StateHasChanged();
                return;
            }

            // Tìm đường đi từ gốc đến node cần chỉnh sửa
            var pathToNode = GetPathToNode(selectedNode);

            // Di chuyển controller theo đường đi tới node cần chỉnh sửa
            await MoveControllerAlongPath(pathToNode);

            // Kiểm tra xem node cần xóa có tồn tại trong cây không
            bool isDeleted = bstService.DeleteNode(selectedNode.Value);

            // Nếu node không tồn tại, hiển thị thông báo lỗi, hủy chọn và thoát
            if (!isDeleted)
            {
                statusMessage = $"Node {selectedNode.Value} does not exist. Edit operation canceled.";
                showController = false;
                selectedNode = null; // Hủy chọn node để tránh lỗi trạng thái
                isTraversing = false;
                StateHasChanged();
                return;
            }

            // Xóa node thành công, cập nhật lại `selectedNode`
            selectedNode = null;

            // Thêm node mới với giá trị đã chỉnh sửa
            var newNodeID = bstService.AddNode(newNodeValue);

            showController = false;
            statusMessage = "Edit Success";

            OnInitialized();

            // Cập nhật giao diện cây và tô sáng node mới
            UpdateTreeDrawing();
            HighlightNode(newNodeID);

            // Đợi 2 giây rồi bỏ tô sáng node mới
            await Task.Delay(2000);
            RemoveHighlighting();
            UpdateTreeDrawing();

            // Gọi OnNodeClick với node vừa thêm để chọn và hiển thị node mới
            var newNode = bstService.FindNodeFromRoot(newNodeValue);
            if (newNode != null)
            {
                OnNodeClick(newNode);
                statusMessage = $"Update {newNodeValue} successfully";

            }
            isTraversing = false;
        }

        isTraversing = false;
    }

    private async Task StartControllerMovement(Vector2 destination)
    {
        await binaryTreeService.MoveControllerToPosition(
            controllerPosition, destination, Val3,
            (newPosition) =>
            {
                controllerPosition = newPosition; // Cập nhật vị trí kiểm soát viên
                InvokeAsync(StateHasChanged); // Cập nhật giao diện
            });
    }

    private void UpdateTraversalOrderFragment(int index)
    {
        traversalOrderFragment = builder => { };

        // Kiểm tra nếu traversalSteps chưa được khởi tạo hoặc rỗng
        if (traversalSteps == null || traversalSteps.Count == 0)
        {
            statusMessage = "No traversal steps to display.";
            StateHasChanged();
            return;
        }

        // Kiểm tra chỉ số index hợp lệ
        if (index < 0 || index >= traversalSteps.Count)
        {
            statusMessage = "Invalid traversal step index.";
            StateHasChanged();
            return;
        }

        // Khởi tạo RenderFragment để hiển thị các bước đã duyệt
        traversalOrderFragment = builder =>
        {
            for (int i = 0; i <= index; i++)
            {
                builder.OpenElement(0, "span");
                builder.AddContent(1, traversalSteps[i].Value);
                builder.CloseElement();

                if (i < traversalSteps.Count - 1)
                {
                    builder.OpenElement(2, "span");
                    builder.AddContent(3, " ⭢ ");
                    builder.CloseElement();
                }
            }
        };

        // Cập nhật giao diện sau khi tạo xong RenderFragment
        StateHasChanged();
    }

    // Hàm thay đổi phương thức tìm kiếm
    private void OnSearchMethodChange(ChangeEventArgs e)
    {
        selectedSearchMethod = e.Value?.ToString() ?? "bst";
    }

    private async Task StartFindNodeAnimation() // Hàm này dùng để tìm kiếm node theo phương pháp đã chọn
    {
        if (isTraversing) return; // Nếu đang duyệt, không thực hiện thêm.

        isTraversing = true;
        traversalSteps = new List<TraversalStep>(); // Khởi tạo lại danh sách trước mỗi lần tìm kiếm

        switch (selectedSearchMethod)
        {
            case "dfs":
                bool found = await DFSVisualization(bstService.Root, newNodeValue, traversalSteps);
                if (!found)
                {
                    statusMessage = $"Node {newNodeValue} not found.";
                }
                break;

            case "bfs":
                bool bfsFound = await BFSVisualization(bstService.Root, newNodeValue, traversalSteps);
                if (!bfsFound)
                {
                    statusMessage = $"Node {newNodeValue} not found.";
                }
                break;
            case "bst":
                await BSTVisualization(newNodeValue);
                break;

            default:
                statusMessage = "Invalid search method selected.";
                break;
        }

        isTraversing = false;
        StateHasChanged(); // Cập nhật giao diện
    }

    private async Task<bool> DFSVisualization(NodeService? node, int targetValue, List<TraversalStep> traversalSteps)
    {
        // Kiểm tra node mục tiêu trước khi bắt đầu
        if (node == bstService.Root)
        {
            // Reset trạng thái trước khi tìm kiếm
            OnInitialized();

            var targetNode = bstService.SearchNode(bstService.Root, targetValue);
            if (targetNode == null)
            {
                statusMessage = $"Node {targetValue} not found.";
                StateHasChanged();
                return false;
            }
        }

        if (node == null) return false;

        // Thêm node hiện tại vào danh sách các bước duyệt
        var step = new TraversalStep(node);
        traversalSteps.Add(step);

        // Di chuyển controller đến node hiện tại
        showController = true;
        statusMessage = $"Searching for node {targetValue}...";
        await StartControllerMovement(new Vector2((float)node.PositionX, (float)node.PositionY));
        UpdateTraversalOrderFragment(traversalSteps.Count - 1);

        // Tô sáng node hiện tại
        node.IsHighlighted = true;
        UpdateTreeDrawing();
        await Task.Delay((int)(1000 / Val3));

        // Kiểm tra nếu đây là node cần tìm
        if (node.Value == targetValue)
        {
            await Task.Delay(2000);
            showController = false;
            node.IsFound = true;
            statusMessage = $"Found node {targetValue} successfully.";
            UpdateTreeDrawing();
            return true;
        }

        // Tạo danh sách để lưu lại lộ trình quay về các node cha khi hoàn tất duyệt nhánh con
        var backtrackPath = new List<NodeService>();

        // Duyệt nhánh trái và lưu lộ trình quay lại
        if (node.LeftChild != null)
        {
            backtrackPath.Add(node); // Lưu node cha hiện tại trước khi duyệt nhánh trái
            bool foundInLeft = await DFSVisualization(node.LeftChild, targetValue, traversalSteps);
            if (foundInLeft) return true;

            // Nếu không tìm thấy ở nhánh trái, quay lại từng node cha
            await BacktrackToParent(backtrackPath);
        }

        // Duyệt nhánh phải và lưu lộ trình quay lại
        if (node.RightChild != null)
        {
            backtrackPath.Add(node); // Lưu node cha hiện tại trước khi duyệt nhánh phải
            bool foundInRight = await DFSVisualization(node.RightChild, targetValue, traversalSteps);
            if (foundInRight) return true;

            // Nếu không tìm thấy ở nhánh phải, quay lại từng node cha
            await BacktrackToParent(backtrackPath);
        }

        UpdateTreeDrawing();
        return false;
    }

    private async Task BacktrackToParent(List<NodeService> backtrackPath)
    {
        for (int i = backtrackPath.Count - 1; i >= 0; i--)
        {
            var parentNode = backtrackPath[i];
            await StartControllerMovement(new Vector2((float)parentNode.PositionX, (float)parentNode.PositionY));
            await Task.Delay((int)(1000 / Val3));
            UpdateTreeDrawing();
        }
        backtrackPath.Clear(); // Xóa lộ trình sau khi quay lại hoàn tất
    }

    private async Task<bool> BFSVisualization(NodeService? root, int targetValue, List<TraversalStep> traversalSteps)
    {
        // Reset trạng thái trước khi bắt đầu
        OnInitialized();
        // Kiểm tra nếu cây rỗng
        if (root == null)
        {
            statusMessage = "Tree is empty.";
            StateHasChanged();
            return false;
        }

        // Kiểm tra nếu node mục tiêu không tồn tại
        var targetNode = bstService.SearchNode(root, targetValue);
        if (targetNode == null)
        {
            statusMessage = $"Node {targetValue} not found.";
            StateHasChanged();
            return false;
        }

        var queue = new Queue<NodeService>();
        queue.Enqueue(root);

        while (queue.Count > 0)
        {
            var currentNode = queue.Dequeue();

            // Thêm node hiện tại vào danh sách các bước đã duyệt
            var step = new TraversalStep(currentNode);
            traversalSteps.Add(step);

            // Di chuyển controller tới node hiện tại
            showController = true;
            statusMessage = $"Searching for node {targetValue}...";
            await StartControllerMovement(new Vector2((float)currentNode.PositionX, (float)currentNode.PositionY));

            // Cập nhật UI với node mới được thêm vào
            UpdateTraversalOrderFragment(traversalSteps.Count - 1);

            // Tô sáng node hiện tại và giữ sáng cho đến khi kết thúc
            currentNode.IsHighlighted = true;
            UpdateTreeDrawing();
            await Task.Delay((int)(1000 / Val3));

            // Kiểm tra nếu đây là node cần tìm
            if (currentNode.Value == targetValue)
            {
                await Task.Delay(2000);

                currentNode.IsFound = true;
                statusMessage = $"Found node {targetValue} successfully.";

                showController = false;
                UpdateTreeDrawing();
                return true;
            }

            // Thêm các node con vào hàng đợi (trái trước, phải sau)
            if (currentNode.LeftChild != null) queue.Enqueue(currentNode.LeftChild);
            if (currentNode.RightChild != null) queue.Enqueue(currentNode.RightChild);
        }

        UpdateTreeDrawing();

        return false;
    }

    private async Task BSTVisualization(int value)
    {
        // Reset trạng thái và vị trí controller trước khi bắt đầu tìm kiếm
        OnInitialized();

        // Xóa danh sách traversalSteps
        traversalSteps.Clear();

        // Tìm kiếm node mục tiêu
        var targetNode = bstService.SearchNode(bstService.Root, value);

        if (targetNode == null)
        {
            // Node không tồn tại
            statusMessage = $"Node {value} not found.";
            StateHasChanged();
            return;
        }

        // Lấy đường dẫn từ root đến targetNode
        var path = GetPathToNode(targetNode);

        if (path.Count == 0)
        {
            statusMessage = $"No path found to Node {value}.";
            StateHasChanged();
            return;
        }

        // Hiển thị controller trước khi bắt đầu di chuyển
        showController = true;
        StateHasChanged();

        // Xử lý riêng cho root
        var root = bstService.Root;
        if (root != null)
        {
            // Tô sáng root
            root.IsHighlighted = true;
            UpdateTreeDrawing();

            // Thêm root vào traversalSteps
            traversalSteps.Add(new TraversalStep(root));
            UpdateTraversalOrderFragment(traversalSteps.Count - 1);
        }

        // Di chuyển qua từng node trên đường đi
        foreach (var line in path)
        {
            // Tìm node hiện tại dựa trên vị trí cuối của line
            var currentNode = bstService.GetNodeByPosition(line.x2, line.y2);

            if (currentNode != null)
            {
                // Di chuyển controller tới node hiện tại
                var destination = new Vector2((float)line.x2, (float)line.y2);
                statusMessage = $"Searching for node {value}...";
                await StartControllerMovement(destination);

                // Sau khi controller đến, tô sáng node hiện tại
                currentNode.IsHighlighted = true;
                UpdateTreeDrawing();

                // Thêm node hiện tại vào traversalSteps
                traversalSteps.Add(new TraversalStep(currentNode));
                UpdateTraversalOrderFragment(traversalSteps.Count - 1);

                // Chờ thêm để hiển thị node rõ ràng
                await Task.Delay((int)(1000 / Val3));
            }
        }

        // Tô sáng node mục tiêu (node cuối cùng)
        targetNode.IsHighlighted = true;
        UpdateTreeDrawing();

        // Cập nhật trạng thái
        targetNode.IsFound = true;
        statusMessage = $"Found node {value} successfully.";

        // Ẩn controller sau khi hoàn thành
        showController = false;
        StateHasChanged();
    }

    private List<(double x1, double y1, double x2, double y2)> GetPathToNode(NodeService targetNode)
    {
        // Lấy tất cả các đường nối từ BinaryTreeService
        var allLines = bstService.GetLines()
                         .Select(line => (line.x1, line.y1, line.x2, line.y2))
                         .ToList();

        // Gọi hàm CollectLinesToNode từ service
        return binaryTreeService.CollectLinesToNode(targetNode, allLines);
    }

    private async Task MoveControllerAlongPath(List<(double x1, double y1, double x2, double y2)> path)
    {
        showController = true; // Hiển thị controller
        StateHasChanged(); // Cập nhật giao diện

        foreach (var line in path)
        {
            var destination = new Vector2((float)line.x2, (float)line.y2);

            // Di chuyển controller tới điểm cuối của line hiện tại
            await StartControllerMovement(destination);
        }
    }
}
